// Generated by LiveScript 1.6.0
(function(){
  var Collision, Quad, QuadTree;
  window.Collision = Collision = (function(){
    Collision.displayName = 'Collision';
    var X_BOUNDS, Y_BOUNDS, prototype = Collision.prototype, constructor = Collision;
    X_BOUNDS = 24.0;
    Y_BOUNDS = 15.0;
    Collision.objs = [];
    Collision.check = function(objs, player){
      var i$, len$, obj, quad, quadTree;
      this.objs = objs;
      player.collidingWith = [];
      this.checkBounds(player);
      for (i$ = 0, len$ = objs.length; i$ < len$; ++i$) {
        obj = objs[i$];
        this.checkBounds(obj);
      }
      quad = new Quad(-X_BOUNDS, -Y_BOUNDS, 2 * X_BOUNDS, 2 * Y_BOUNDS);
      quadTree = new QuadTree(objs.concat(player), quad);
      return this.checkCollisionFromTree(quadTree);
    };
    Collision.checkBounds = function(obj){
      var x, y, vx, vy, _x, _y;
      x = obj.pos[0];
      y = obj.pos[2];
      vx = obj.vel[0];
      vy = obj.vel[2];
      _x = x + vx;
      _y = y + vy;
      if (Math.abs(_x) > X_BOUNDS) {
        obj.vel[0] = 0;
      }
      if (Math.abs(_y) > Y_BOUNDS) {
        obj.vel[2] = 0;
      }
      if (x > X_BOUNDS) {
        obj.pos[0] = X_BOUNDS;
      } else if (x < -X_BOUNDS) {
        obj.pos[0] = -X_BOUNDS;
      }
      if (y > X_BOUNDS) {
        return obj.pos[2] = Y_BOUNDS;
      } else if (y < -Y_BOUNDS) {
        return obj.pos[2] = -Y_BOUNDS;
      }
    };
    Collision.checkCollisionFromTree = function(quadTree){
      var i$, to$, i, curObj, otherObjs, j$, len$, otherObj;
      if (!quadTree) {
        return;
      }
      for (i$ = 0, to$ = quadTree.objs.length; i$ < to$; ++i$) {
        i = i$;
        curObj = quadTree.objs.pop();
        otherObjs = this.getTreeElements(quadTree);
        for (j$ = 0, len$ = otherObjs.length; j$ < len$; ++j$) {
          otherObj = otherObjs[j$];
          this.checkCollision(curObj, otherObj);
        }
      }
      this.checkCollisionFromTree(quadTree.node1);
      this.checkCollisionFromTree(quadTree.node2);
      this.checkCollisionFromTree(quadTree.node3);
      return this.checkCollisionFromTree(quadTree.node4);
    };
    Collision.checkCollision = function(obj1, obj2){
      var x1, y1, x2, y2, normal, dot1, dot2, cancelVel1, cancelVel2;
      x1 = obj1.pos[0] + obj1.vel[0];
      y1 = obj1.pos[2] + obj1.vel[2];
      x2 = obj2.pos[0] + obj2.vel[0];
      y2 = obj2.pos[2] + obj2.vel[2];
      if (Math.sqrt(Math.pow(x1 - x2, 2) + Math.pow(y1 - y2, 2)) < obj1.radius + obj2.radius) {
        normal = vec3.create();
        vec3.sub(normal, obj2.pos, obj1.pos);
        vec3.normalize(normal, normal);
        dot1 = vec3.dot(obj1.vel, normal);
        dot2 = vec3.dot(obj2.vel, normal);
        cancelVel1 = [];
        vec3.scale(cancelVel1, normal, dot1);
        cancelVel2 = [];
        vec3.scale(cancelVel2, normal, dot2);
        vec3.sub(obj1.pos, obj1.pos, cancelVel1);
        return vec3.sub(obj2.pos, obj2.pos, cancelVel2);
      }
    };
    Collision.getTreeElements = function(quadTree){
      if (!quadTree) {
        return [];
      } else {
        return quadTree.objs.concat(this.getTreeElements(quadTree.node1), this.getTreeElements(quadTree.node2), this.getTreeElements(quadTree.node3), this.getTreeElements(quadTree.node4));
      }
    };
    Collision.raycast = function(origin, dir, length){
      var caughtObj, minProj, i$, ref$, len$, obj, originDist, proj, cross, len1, len2, dist;
      caughtObj = null;
      minProj = 65535;
      for (i$ = 0, len$ = (ref$ = this.objs).length; i$ < len$; ++i$) {
        obj = ref$[i$];
        originDist = [];
        vec3.sub(originDist, obj.pos, origin);
        proj = vec3.dot(originDist, dir);
        if (proj < length && proj > 0.0) {
          cross = [];
          vec3.cross(cross, dir, originDist);
          len1 = vec3.len(cross);
          len2 = vec3.len(dir);
          dist = len1 / len2;
          if (dist < obj.radius) {
            if (proj < minProj) {
              caughtObj = obj;
              minProj = proj;
            }
          }
        }
      }
      return caughtObj;
    };
    Collision.distFromStraight = function(origin, dir, obj){
      var sub, cross, len1, len2;
      sub = [];
      vec3.sub(sub, obj.pos, origin);
      cross = [];
      vec3.cross(cross, dir, sub);
      len1 = vec3.len(cross);
      len2 = vec3.len(dir);
      return len1 / len2;
    };
    function Collision(){}
    return Collision;
  }());
  Quad = (function(){
    Quad.displayName = 'Quad';
    var prototype = Quad.prototype, constructor = Quad;
    function Quad(x, y, w, h){
      this.x = x;
      this.y = y;
      this.w = w;
      this.h = h;
    }
    Quad.prototype.isInside = function(x, y, r){
      if (x - r > this.x && x + r < this.x + this.w && y - r > this.y && y + r < this.y + this.h) {
        return true;
      } else {
        return false;
      }
    };
    return Quad;
  }());
  QuadTree = (function(){
    QuadTree.displayName = 'QuadTree';
    var prototype = QuadTree.prototype, constructor = QuadTree;
    function QuadTree(objs, quad, level){
      var bound1, bound2, bound3, bound4, objs1, objs2, objs3, objs4, i$, len$, obj, x, y, r;
      level == null && (level = 0);
      this.objs = [];
      if (objs.length === 0) {
        this.node1 = null;
        this.node2 = null;
        this.node3 = null;
        this.node4 = null;
        return;
      }
      bound1 = new Quad(quad.x + quad.w / 2, quad.y + quad.h / 2, quad.w / 2, quad.h / 2);
      bound2 = new Quad(quad.x, quad.y + quad.h / 2, quad.w / 2, quad.h / 2);
      bound3 = new Quad(quad.x, quad.y, quad.w / 2, quad.h / 2);
      bound4 = new Quad(quad.x + quad.w / 2, quad.y, quad.w / 2, quad.h / 2);
      objs1 = [];
      objs2 = [];
      objs3 = [];
      objs4 = [];
      for (i$ = 0, len$ = objs.length; i$ < len$; ++i$) {
        obj = objs[i$];
        x = obj.pos[0] + obj.vel[0];
        y = obj.pos[2] + obj.vel[2];
        r = 1.0;
        if (bound1.isInside(x, y, r)) {
          objs1.push(obj);
        } else if (bound2.isInside(x, y, r)) {
          objs2.push(obj);
        } else if (bound3.isInside(x, y, r)) {
          objs3.push(obj);
        } else if (bound4.isInside(x, y, r)) {
          objs4.push(obj);
        } else {
          this.objs.push(obj);
        }
      }
      if (objs1) {
        this.node1 = new QuadTree(objs1, bound1, level + 1);
      } else {
        this.node1 = null;
      }
      if (objs2) {
        this.node2 = new QuadTree(objs2, bound1, level + 1);
      } else {
        this.node1 = null;
      }
      if (objs3) {
        this.node3 = new QuadTree(objs3, bound1, level + 1);
      } else {
        this.node3 = null;
      }
      if (objs4) {
        this.node4 = new QuadTree(objs4, bound4, level + 1);
      } else {
        this.node4 = null;
      }
    }
    return QuadTree;
  }());
}).call(this);
